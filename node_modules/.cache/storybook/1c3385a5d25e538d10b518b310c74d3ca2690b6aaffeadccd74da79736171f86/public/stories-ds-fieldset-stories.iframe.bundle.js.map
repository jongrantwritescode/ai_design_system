{"version":3,"file":"stories-ds-fieldset-stories.iframe.bundle.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://ai-design-system/./src/components/ds-checkbox.js","webpack://ai-design-system/./src/components/ds-fieldset.js","webpack://ai-design-system/./src/components/ds-legend.js","webpack://ai-design-system/./src/components/ds-radio.js","webpack://ai-design-system/./src/components/ds-text-input.js","webpack://ai-design-system/./src/stories/ds-fieldset.stories.js"],"sourcesContent":["/**\n * ds-checkbox - A checkbox component that wraps native checkbox input elements\n */\nclass DsCheckbox extends HTMLElement {\n    constructor() {\n        super();\n        \n        // Attach shadow root with open mode for experimentation\n        const shadowRoot = this.attachShadow({ mode: 'open' });\n        \n        // Define the template with internal markup and styles\n        const template = document.createElement('template');\n        template.innerHTML = `\n            <style>\n                @import url('/src/design_system/styles.css');\n                \n                :host {\n                    display: inline-block;\n                }\n                \n                .wrapper {\n                    display: flex;\n                    align-items: center;\n                }\n            </style>\n            <div class=\"wrapper\">\n                <input type=\"checkbox\" id=\"checkbox\" part=\"checkbox\">\n                <slot></slot>\n            </div>\n        `;\n        \n        // Append the template's content to the shadow root\n        shadowRoot.appendChild(template.content.cloneNode(true));\n        \n        // Store reference to the internal checkbox for attribute changes\n        this.checkbox = shadowRoot.querySelector('input[type=\"checkbox\"]');\n        \n        // Set up event listeners\n        this.setupEventListeners();\n    }\n    \n    /**\n     * Define which attributes should trigger attributeChangedCallback\n     */\n    static get observedAttributes() {\n        return ['name', 'value', 'checked', 'disabled', 'readonly', 'required', 'id'];\n    }\n    \n    /**\n     * React to attribute changes and apply corresponding properties to the internal checkbox\n     */\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (oldValue === newValue) return; // No change\n        \n        switch (name) {\n            case 'name':\n                this.checkbox.name = newValue || '';\n                break;\n                \n            case 'value':\n                this.checkbox.value = newValue || '';\n                break;\n                \n            case 'checked':\n                if (this.hasAttribute('checked')) {\n                    this.checkbox.checked = true;\n                } else {\n                    this.checkbox.checked = false;\n                }\n                break;\n                \n            case 'disabled':\n                if (this.hasAttribute('disabled')) {\n                    this.checkbox.disabled = true;\n                } else {\n                    this.checkbox.disabled = false;\n                }\n                break;\n                \n            case 'readonly':\n                if (this.hasAttribute('readonly')) {\n                    this.checkbox.readOnly = true;\n                } else {\n                    this.checkbox.readOnly = false;\n                }\n                break;\n                \n            case 'required':\n                if (this.hasAttribute('required')) {\n                    this.checkbox.required = true;\n                } else {\n                    this.checkbox.required = false;\n                }\n                break;\n                \n            case 'id':\n                this.checkbox.id = newValue || '';\n                break;\n        }\n    }\n    \n    /**\n     * Set up event listeners to re-dispatch events from the host element\n     */\n    setupEventListeners() {\n        const events = ['change', 'focus', 'blur'];\n        \n        events.forEach(eventType => {\n            this.checkbox.addEventListener(eventType, (event) => {\n                // Create a new event to dispatch from the host\n                const newEvent = new Event(eventType, {\n                    bubbles: true,\n                    composed: true,\n                    cancelable: true\n                });\n                \n                // Copy relevant properties\n                if (eventType === 'change') {\n                    newEvent.target = this;\n                    newEvent.currentTarget = this;\n                }\n                \n                this.dispatchEvent(newEvent);\n            });\n        });\n    }\n    \n    /**\n     * Property getters and setters to mirror the internal checkbox\n     */\n    get checked() {\n        return this.checkbox.checked;\n    }\n    \n    set checked(val) {\n        this.checkbox.checked = val;\n    }\n    \n    get value() {\n        return this.checkbox.value;\n    }\n    \n    set value(val) {\n        this.checkbox.value = val;\n    }\n    \n    get name() {\n        return this.checkbox.name;\n    }\n    \n    set name(val) {\n        this.checkbox.name = val;\n    }\n    \n    get disabled() {\n        return this.checkbox.disabled;\n    }\n    \n    set disabled(val) {\n        this.checkbox.disabled = val;\n    }\n    \n    get readonly() {\n        return this.checkbox.readOnly;\n    }\n    \n    set readonly(val) {\n        this.checkbox.readOnly = val;\n    }\n    \n    get required() {\n        return this.checkbox.required;\n    }\n    \n    set required(val) {\n        this.checkbox.required = val;\n    }\n    \n    /**\n     * Called when the element is connected to the DOM\n     * Apply initial attributes\n     */\n    connectedCallback() {\n        // Apply initial attributes\n        this.attributeChangedCallback('name', null, this.getAttribute('name'));\n        this.attributeChangedCallback('value', null, this.getAttribute('value'));\n        this.attributeChangedCallback('checked', null, this.getAttribute('checked'));\n        this.attributeChangedCallback('disabled', null, this.getAttribute('disabled'));\n        this.attributeChangedCallback('readonly', null, this.getAttribute('readonly'));\n        this.attributeChangedCallback('required', null, this.getAttribute('required'));\n        this.attributeChangedCallback('id', null, this.getAttribute('id'));\n    }\n}\n\n// Register the custom element\ncustomElements.define('ds-checkbox', DsCheckbox); ","/**\n * ds-fieldset - A fieldset component that wraps native fieldset elements\n * Used for grouping form elements\n */\nclass DsFieldset extends HTMLElement {\n    constructor() {\n        super();\n        \n        // Attach shadow root with open mode for experimentation\n        const shadowRoot = this.attachShadow({ mode: 'open' });\n        \n        // Define the template with internal markup and styles\n        const template = document.createElement('template');\n        template.innerHTML = `\n            <style>\n                @import url('/src/design_system/styles.css');\n                \n                :host {\n                    display: block;\n                }\n                \n                .wrapper {\n                    width: 100%;\n                }\n            </style>\n            <div class=\"wrapper\">\n                <fieldset part=\"fieldset\">\n                    <slot></slot>\n                </fieldset>\n            </div>\n        `;\n        \n        // Append the template's content to the shadow root\n        shadowRoot.appendChild(template.content.cloneNode(true));\n        \n        // Store reference to the internal fieldset for attribute changes\n        this.fieldset = shadowRoot.querySelector('fieldset');\n        \n        // Set up event listeners\n        this.setupEventListeners();\n    }\n    \n    /**\n     * Define which attributes should trigger attributeChangedCallback\n     */\n    static get observedAttributes() {\n        return []; // No specific attributes for fieldset\n    }\n    \n    /**\n     * Set up event listeners\n     */\n    setupEventListeners() {\n        // Fieldsets don't typically have interactive events\n        // But we can listen for form-related events if needed\n    }\n    \n    /**\n     * Called when the element is connected to the DOM\n     * Apply any initial setup if needed\n     */\n    connectedCallback() {\n        // No specific initialization needed for fieldset\n        // It's designed to be a simple wrapper\n    }\n}\n\n// Register the custom element\ncustomElements.define('ds-fieldset', DsFieldset); ","/**\n * ds-legend - A legend component that wraps native legend elements\n * Used within ds-fieldset components\n */\nclass DsLegend extends HTMLElement {\n    constructor() {\n        super();\n        \n        // Attach shadow root with open mode for experimentation\n        const shadowRoot = this.attachShadow({ mode: 'open' });\n        \n        // Define the template with internal markup and styles\n        const template = document.createElement('template');\n        template.innerHTML = `\n            <style>\n                @import url('/src/design_system/styles.css');\n                \n                :host {\n                    display: block;\n                }\n                \n                .wrapper {\n                    width: 100%;\n                }\n            </style>\n            <div class=\"wrapper\">\n                <legend part=\"legend\">\n                    <slot></slot>\n                </legend>\n            </div>\n        `;\n        \n        // Append the template's content to the shadow root\n        shadowRoot.appendChild(template.content.cloneNode(true));\n        \n        // Store reference to the internal legend for attribute changes\n        this.legend = shadowRoot.querySelector('legend');\n        \n        // Set up event listeners\n        this.setupEventListeners();\n    }\n    \n    /**\n     * Define which attributes should trigger attributeChangedCallback\n     */\n    static get observedAttributes() {\n        return []; // No specific attributes for legend\n    }\n    \n    /**\n     * Set up event listeners\n     */\n    setupEventListeners() {\n        // Legends don't typically have interactive events\n        // But we can listen for form-related events if needed\n    }\n    \n    /**\n     * Called when the element is connected to the DOM\n     * Apply any initial setup if needed\n     */\n    connectedCallback() {\n        // No specific initialization needed for legend\n        // It's designed to be a simple wrapper\n    }\n}\n\n// Register the custom element\ncustomElements.define('ds-legend', DsLegend); ","/**\n * ds-radio - A radio button component that wraps native radio input elements\n */\nclass DsRadio extends HTMLElement {\n    constructor() {\n        super();\n        \n        // Attach shadow root with open mode for experimentation\n        const shadowRoot = this.attachShadow({ mode: 'open' });\n        \n        // Define the template with internal markup and styles\n        const template = document.createElement('template');\n        template.innerHTML = `\n            <style>\n                @import url('/src/design_system/styles.css');\n                \n                :host {\n                    display: inline-block;\n                }\n                \n                .wrapper {\n                    display: flex;\n                    align-items: center;\n                }\n            </style>\n            <div class=\"wrapper\">\n                <input type=\"radio\" id=\"radio\" part=\"radio\">\n                <slot></slot>\n            </div>\n        `;\n        \n        // Append the template's content to the shadow root\n        shadowRoot.appendChild(template.content.cloneNode(true));\n        \n        // Store reference to the internal radio for attribute changes\n        this.radio = shadowRoot.querySelector('input[type=\"radio\"]');\n        \n        // Set up event listeners\n        this.setupEventListeners();\n    }\n    \n    /**\n     * Define which attributes should trigger attributeChangedCallback\n     */\n    static get observedAttributes() {\n        return ['name', 'value', 'checked', 'disabled', 'readonly', 'required', 'id'];\n    }\n    \n    /**\n     * React to attribute changes and apply corresponding properties to the internal radio\n     */\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (oldValue === newValue) return; // No change\n        \n        switch (name) {\n            case 'name':\n                this.radio.name = newValue || '';\n                break;\n                \n            case 'value':\n                this.radio.value = newValue || '';\n                break;\n                \n            case 'checked':\n                if (this.hasAttribute('checked')) {\n                    this.radio.checked = true;\n                } else {\n                    this.radio.checked = false;\n                }\n                break;\n                \n            case 'disabled':\n                if (this.hasAttribute('disabled')) {\n                    this.radio.disabled = true;\n                } else {\n                    this.radio.disabled = false;\n                }\n                break;\n                \n            case 'readonly':\n                if (this.hasAttribute('readonly')) {\n                    this.radio.readOnly = true;\n                } else {\n                    this.radio.readOnly = false;\n                }\n                break;\n                \n            case 'required':\n                if (this.hasAttribute('required')) {\n                    this.radio.required = true;\n                } else {\n                    this.radio.required = false;\n                }\n                break;\n                \n            case 'id':\n                this.radio.id = newValue || '';\n                break;\n        }\n    }\n    \n    /**\n     * Set up event listeners to re-dispatch events from the host element\n     */\n    setupEventListeners() {\n        const events = ['change', 'focus', 'blur'];\n        \n        events.forEach(eventType => {\n            this.radio.addEventListener(eventType, (event) => {\n                // Create a new event to dispatch from the host\n                const newEvent = new Event(eventType, {\n                    bubbles: true,\n                    composed: true,\n                    cancelable: true\n                });\n                \n                // Copy relevant properties\n                if (eventType === 'change') {\n                    newEvent.target = this;\n                    newEvent.currentTarget = this;\n                }\n                \n                this.dispatchEvent(newEvent);\n            });\n        });\n    }\n    \n    /**\n     * Property getters and setters to mirror the internal radio\n     */\n    get checked() {\n        return this.radio.checked;\n    }\n    \n    set checked(val) {\n        this.radio.checked = val;\n    }\n    \n    get value() {\n        return this.radio.value;\n    }\n    \n    set value(val) {\n        this.radio.value = val;\n    }\n    \n    get name() {\n        return this.radio.name;\n    }\n    \n    set name(val) {\n        this.radio.name = val;\n    }\n    \n    get disabled() {\n        return this.radio.disabled;\n    }\n    \n    set disabled(val) {\n        this.radio.disabled = val;\n    }\n    \n    get readonly() {\n        return this.radio.readOnly;\n    }\n    \n    set readonly(val) {\n        this.radio.readOnly = val;\n    }\n    \n    get required() {\n        return this.radio.required;\n    }\n    \n    set required(val) {\n        this.radio.required = val;\n    }\n    \n    /**\n     * Called when the element is connected to the DOM\n     * Apply initial attributes\n     */\n    connectedCallback() {\n        // Apply initial attributes\n        this.attributeChangedCallback('name', null, this.getAttribute('name'));\n        this.attributeChangedCallback('value', null, this.getAttribute('value'));\n        this.attributeChangedCallback('checked', null, this.getAttribute('checked'));\n        this.attributeChangedCallback('disabled', null, this.getAttribute('disabled'));\n        this.attributeChangedCallback('readonly', null, this.getAttribute('readonly'));\n        this.attributeChangedCallback('required', null, this.getAttribute('required'));\n        this.attributeChangedCallback('id', null, this.getAttribute('id'));\n    }\n}\n\n// Register the custom element\ncustomElements.define('ds-radio', DsRadio); ","/**\n * ds-text-input - A text input component that wraps native input elements\n * Supports: text, email, password, number, tel, url, search\n */\nclass DsTextInput extends HTMLElement {\n    constructor() {\n        super();\n        \n        // Attach shadow root with open mode for experimentation\n        const shadowRoot = this.attachShadow({ mode: 'open' });\n        \n        // Define the template with internal markup and styles\n        const template = document.createElement('template');\n        template.innerHTML = `\n            <style>\n                @import url('/src/design_system/styles.css');\n                \n                :host {\n                    display: block;\n                }\n                \n                .wrapper {\n                    width: 100%;\n                }\n            </style>\n            <div class=\"wrapper\">\n                <input id=\"input\" part=\"input\" type=\"text\">\n                <slot></slot>\n            </div>\n        `;\n        \n        // Append the template's content to the shadow root\n        shadowRoot.appendChild(template.content.cloneNode(true));\n        \n        // Store reference to the internal input for attribute changes\n        this.input = shadowRoot.querySelector('input');\n        \n        // Set up event listeners\n        this.setupEventListeners();\n    }\n    \n    /**\n     * Define which attributes should trigger attributeChangedCallback\n     */\n    static get observedAttributes() {\n        return ['type', 'value', 'placeholder', 'disabled', 'readonly', 'required', 'name', 'id', 'aria-label'];\n    }\n    \n    /**\n     * React to attribute changes and apply corresponding properties to the internal input\n     */\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (oldValue === newValue) return; // No change\n        \n        switch (name) {\n            case 'type':\n                this.input.type = newValue || 'text';\n                break;\n                \n            case 'value':\n                this.input.value = newValue || '';\n                break;\n                \n            case 'placeholder':\n                this.input.placeholder = newValue || '';\n                break;\n                \n            case 'disabled':\n                if (this.hasAttribute('disabled')) {\n                    this.input.disabled = true;\n                } else {\n                    this.input.disabled = false;\n                }\n                break;\n                \n            case 'readonly':\n                if (this.hasAttribute('readonly')) {\n                    this.input.readOnly = true;\n                } else {\n                    this.input.readOnly = false;\n                }\n                break;\n                \n            case 'required':\n                if (this.hasAttribute('required')) {\n                    this.input.required = true;\n                } else {\n                    this.input.required = false;\n                }\n                break;\n                \n            case 'name':\n                this.input.name = newValue || '';\n                break;\n                \n            case 'id':\n                this.input.id = newValue || '';\n                break;\n                \n            case 'aria-label':\n                this.input.setAttribute('aria-label', newValue || '');\n                break;\n        }\n    }\n    \n    /**\n     * Set up event listeners to re-dispatch events from the host element\n     */\n    setupEventListeners() {\n        const events = ['input', 'change', 'focus', 'blur'];\n        \n        events.forEach(eventType => {\n            this.input.addEventListener(eventType, (event) => {\n                // Create a new event to dispatch from the host\n                const newEvent = new Event(eventType, {\n                    bubbles: true,\n                    composed: true,\n                    cancelable: true\n                });\n                \n                // Copy relevant properties\n                if (eventType === 'input' || eventType === 'change') {\n                    newEvent.target = this;\n                    newEvent.currentTarget = this;\n                }\n                \n                this.dispatchEvent(newEvent);\n            });\n        });\n    }\n    \n    /**\n     * Property getters and setters to mirror the internal input\n     */\n    get value() {\n        return this.input.value;\n    }\n    \n    set value(val) {\n        this.input.value = val;\n    }\n    \n    get type() {\n        return this.input.type;\n    }\n    \n    set type(val) {\n        this.input.type = val;\n    }\n    \n    get disabled() {\n        return this.input.disabled;\n    }\n    \n    set disabled(val) {\n        this.input.disabled = val;\n    }\n    \n    get readonly() {\n        return this.input.readOnly;\n    }\n    \n    set readonly(val) {\n        this.input.readOnly = val;\n    }\n    \n    get required() {\n        return this.input.required;\n    }\n    \n    set required(val) {\n        this.input.required = val;\n    }\n    \n    /**\n     * Called when the element is connected to the DOM\n     * Apply initial attributes\n     */\n    connectedCallback() {\n        // Apply initial attributes\n        this.attributeChangedCallback('type', null, this.getAttribute('type'));\n        this.attributeChangedCallback('value', null, this.getAttribute('value'));\n        this.attributeChangedCallback('placeholder', null, this.getAttribute('placeholder'));\n        this.attributeChangedCallback('disabled', null, this.getAttribute('disabled'));\n        this.attributeChangedCallback('readonly', null, this.getAttribute('readonly'));\n        this.attributeChangedCallback('required', null, this.getAttribute('required'));\n        this.attributeChangedCallback('name', null, this.getAttribute('name'));\n        this.attributeChangedCallback('id', null, this.getAttribute('id'));\n        this.attributeChangedCallback('aria-label', null, this.getAttribute('aria-label'));\n    }\n}\n\n// Register the custom element\ncustomElements.define('ds-text-input', DsTextInput); ","import '../components/ds-fieldset.js';\nimport '../components/ds-legend.js';\nimport '../components/ds-text-input.js';\nimport '../components/ds-radio.js';\nimport '../components/ds-checkbox.js';\n\nexport default {\n  title: 'Components/ds-fieldset',\n  component: 'ds-fieldset',\n  parameters: {\n    docs: {\n      description: {\n        component: 'A fieldset component that wraps native fieldset elements for grouping related form controls.'\n      }\n    }\n  },\n  argTypes: {\n    content: {\n      control: 'text',\n      description: 'The content inside the fieldset'\n    }\n  }\n};\n\nconst Template = (args) => {\n  const element = document.createElement('ds-fieldset');\n  \n  // Set content\n  element.innerHTML = args.content || '<ds-legend>Fieldset Legend</ds-legend>';\n  \n  return element;\n};\n\nexport const Default = Template.bind({});\nDefault.args = {\n  content: '<ds-legend>Personal Information</ds-legend>'\n};\n\n// Fieldset with Form Controls Example\nexport const WithFormControls = () => {\n  const fieldset = document.createElement('ds-fieldset');\n  \n  const legend = document.createElement('ds-legend');\n  legend.innerHTML = 'Contact Information';\n  fieldset.appendChild(legend);\n  \n  const nameInput = document.createElement('ds-text-input');\n  nameInput.setAttribute('type', 'text');\n  nameInput.setAttribute('placeholder', 'Enter your name');\n  nameInput.setAttribute('name', 'name');\n  \n  const emailInput = document.createElement('ds-text-input');\n  emailInput.setAttribute('type', 'email');\n  emailInput.setAttribute('placeholder', 'Enter your email');\n  emailInput.setAttribute('name', 'email');\n  \n  const container = document.createElement('div');\n  container.style.cssText = 'display: flex; flex-direction: column; gap: 16px;';\n  container.appendChild(nameInput);\n  container.appendChild(emailInput);\n  \n  fieldset.appendChild(container);\n  \n  return fieldset;\n};\n\n// Fieldset with Radio Buttons Example\nexport const WithRadioButtons = () => {\n  const fieldset = document.createElement('ds-fieldset');\n  \n  const legend = document.createElement('ds-legend');\n  legend.innerHTML = 'Select your preferred contact method';\n  fieldset.appendChild(legend);\n  \n  const radio1 = document.createElement('ds-radio');\n  radio1.setAttribute('name', 'contact-method');\n  radio1.setAttribute('value', 'email');\n  radio1.innerHTML = 'Email';\n  \n  const radio2 = document.createElement('ds-radio');\n  radio2.setAttribute('name', 'contact-method');\n  radio2.setAttribute('value', 'phone');\n  radio2.setAttribute('checked', '');\n  radio2.innerHTML = 'Phone';\n  \n  const radio3 = document.createElement('ds-radio');\n  radio3.setAttribute('name', 'contact-method');\n  radio3.setAttribute('value', 'mail');\n  radio3.innerHTML = 'Mail';\n  \n  const container = document.createElement('div');\n  container.style.cssText = 'display: flex; flex-direction: column; gap: 8px;';\n  container.appendChild(radio1);\n  container.appendChild(radio2);\n  container.appendChild(radio3);\n  \n  fieldset.appendChild(container);\n  \n  return fieldset;\n};\n\n// Fieldset with Checkboxes Example\nexport const WithCheckboxes = () => {\n  const fieldset = document.createElement('ds-fieldset');\n  \n  const legend = document.createElement('ds-legend');\n  legend.innerHTML = 'Select your interests';\n  fieldset.appendChild(legend);\n  \n  const checkbox1 = document.createElement('ds-checkbox');\n  checkbox1.setAttribute('name', 'interests');\n  checkbox1.setAttribute('value', 'technology');\n  checkbox1.innerHTML = 'Technology';\n  \n  const checkbox2 = document.createElement('ds-checkbox');\n  checkbox2.setAttribute('name', 'interests');\n  checkbox2.setAttribute('value', 'sports');\n  checkbox2.setAttribute('checked', '');\n  checkbox2.innerHTML = 'Sports';\n  \n  const checkbox3 = document.createElement('ds-checkbox');\n  checkbox3.setAttribute('name', 'interests');\n  checkbox3.setAttribute('value', 'music');\n  checkbox3.innerHTML = 'Music';\n  \n  const checkbox4 = document.createElement('ds-checkbox');\n  checkbox4.setAttribute('name', 'interests');\n  checkbox4.setAttribute('value', 'travel');\n  checkbox4.innerHTML = 'Travel';\n  \n  const container = document.createElement('div');\n  container.style.cssText = 'display: flex; flex-direction: column; gap: 8px;';\n  container.appendChild(checkbox1);\n  container.appendChild(checkbox2);\n  container.appendChild(checkbox3);\n  container.appendChild(checkbox4);\n  \n  fieldset.appendChild(container);\n  \n  return fieldset;\n}; ;export const __namedExportsOrder = [\"Default\",\"WithFormControls\",\"WithRadioButtons\",\"WithCheckboxes\"];"],"names":[],"sourceRoot":""}