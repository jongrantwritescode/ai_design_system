{"version":3,"file":"stories-ds-textarea-stories.d8b12f218427e00c9f0c.hot-update.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://ai-design-system/./src/components/ds-textarea.js","webpack://ai-design-system/./src/stories/ds-textarea.stories.js"],"sourcesContent":["/**\n * ds-textarea - A textarea component that wraps native textarea elements\n */\nclass DsTextarea extends HTMLElement {\n    constructor() {\n        super();\n        \n        // Attach shadow root with open mode for experimentation\n        const shadowRoot = this.attachShadow({ mode: 'open' });\n        \n        // Define the template with internal markup and styles\n        const template = document.createElement('template');\n        template.innerHTML = `\n            <style>\n                @import url('/src/design_system/styles.css');\n                \n                :host {\n                    display: block;\n                }\n                \n                .wrapper {\n                    width: 100%;\n                }\n            </style>\n            <div class=\"wrapper\">\n                <textarea id=\"textarea\" part=\"textarea\">\n                    <slot></slot>\n                </textarea>\n            </div>\n        `;\n        \n        // Append the template's content to the shadow root\n        shadowRoot.appendChild(template.content.cloneNode(true));\n        \n        // Store reference to the internal textarea for attribute changes\n        this.textarea = shadowRoot.querySelector('textarea');\n        \n        // Set up event listeners\n        this.setupEventListeners();\n    }\n    \n    /**\n     * Define which attributes should trigger attributeChangedCallback\n     */\n    static get observedAttributes() {\n        return ['value', 'placeholder', 'rows', 'cols', 'disabled', 'readonly', 'required', 'name', 'id'];\n    }\n    \n    /**\n     * React to attribute changes and apply corresponding properties to the internal textarea\n     */\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (oldValue === newValue) return; // No change\n        \n        switch (name) {\n            case 'value':\n                this.textarea.value = newValue || '';\n                break;\n                \n            case 'placeholder':\n                this.textarea.placeholder = newValue || '';\n                break;\n                \n            case 'rows':\n                this.textarea.rows = newValue || '';\n                break;\n                \n            case 'cols':\n                this.textarea.cols = newValue || '';\n                break;\n                \n            case 'disabled':\n                if (this.hasAttribute('disabled')) {\n                    this.textarea.disabled = true;\n                } else {\n                    this.textarea.disabled = false;\n                }\n                break;\n                \n            case 'readonly':\n                if (this.hasAttribute('readonly')) {\n                    this.textarea.readOnly = true;\n                } else {\n                    this.textarea.readOnly = false;\n                }\n                break;\n                \n            case 'required':\n                if (this.hasAttribute('required')) {\n                    this.textarea.required = true;\n                } else {\n                    this.textarea.required = false;\n                }\n                break;\n                \n            case 'name':\n                this.textarea.name = newValue || '';\n                break;\n                \n            case 'id':\n                this.textarea.id = newValue || '';\n                break;\n        }\n    }\n    \n    /**\n     * Set up event listeners to re-dispatch events from the host element\n     */\n    setupEventListeners() {\n        const events = ['input', 'change', 'focus', 'blur'];\n        \n        events.forEach(eventType => {\n            this.textarea.addEventListener(eventType, (event) => {\n                // Create a new event to dispatch from the host\n                const newEvent = new Event(eventType, {\n                    bubbles: true,\n                    composed: true,\n                    cancelable: true\n                });\n                \n                // Copy relevant properties\n                if (eventType === 'input' || eventType === 'change') {\n                    newEvent.target = this;\n                    newEvent.currentTarget = this;\n                }\n                \n                this.dispatchEvent(newEvent);\n            });\n        });\n    }\n    \n    /**\n     * Property getters and setters to mirror the internal textarea\n     */\n    get value() {\n        return this.textarea.value;\n    }\n    \n    set value(val) {\n        this.textarea.value = val;\n    }\n    \n    get placeholder() {\n        return this.textarea.placeholder;\n    }\n    \n    set placeholder(val) {\n        this.textarea.placeholder = val;\n    }\n    \n    get rows() {\n        return this.textarea.rows;\n    }\n    \n    set rows(val) {\n        this.textarea.rows = val;\n    }\n    \n    get cols() {\n        return this.textarea.cols;\n    }\n    \n    set cols(val) {\n        this.textarea.cols = val;\n    }\n    \n    get disabled() {\n        return this.textarea.disabled;\n    }\n    \n    set disabled(val) {\n        this.textarea.disabled = val;\n    }\n    \n    get readonly() {\n        return this.textarea.readOnly;\n    }\n    \n    set readonly(val) {\n        this.textarea.readOnly = val;\n    }\n    \n    get required() {\n        return this.textarea.required;\n    }\n    \n    set required(val) {\n        this.textarea.required = val;\n    }\n    \n    get name() {\n        return this.textarea.name;\n    }\n    \n    set name(val) {\n        this.textarea.name = val;\n    }\n    \n    /**\n     * Called when the element is connected to the DOM\n     * Apply initial attributes\n     */\n    connectedCallback() {\n        // Apply initial attributes\n        this.attributeChangedCallback('value', null, this.getAttribute('value'));\n        this.attributeChangedCallback('placeholder', null, this.getAttribute('placeholder'));\n        this.attributeChangedCallback('rows', null, this.getAttribute('rows'));\n        this.attributeChangedCallback('cols', null, this.getAttribute('cols'));\n        this.attributeChangedCallback('disabled', null, this.getAttribute('disabled'));\n        this.attributeChangedCallback('readonly', null, this.getAttribute('readonly'));\n        this.attributeChangedCallback('required', null, this.getAttribute('required'));\n        this.attributeChangedCallback('name', null, this.getAttribute('name'));\n        this.attributeChangedCallback('id', null, this.getAttribute('id'));\n    }\n}\n\n// Register the custom element\ncustomElements.define('ds-textarea', DsTextarea); ","import '../components/ds-textarea.js';\n\nexport default {\n  title: 'Components/ds-textarea',\n  component: 'ds-textarea',\n  parameters: {\n    docs: {\n      description: {\n        component: 'A textarea component that wraps native textarea elements with support for multi-line text input.'\n      }\n    }\n  },\n  argTypes: {\n    value: {\n      control: 'text',\n      description: 'The current value of the textarea'\n    },\n    placeholder: {\n      control: 'text',\n      description: 'Placeholder text for the textarea'\n    },\n    rows: {\n      control: 'number',\n      description: 'Number of visible rows'\n    },\n    cols: {\n      control: 'number',\n      description: 'Number of visible columns'\n    },\n    disabled: {\n      control: 'boolean',\n      description: 'Whether the textarea is disabled'\n    },\n    readonly: {\n      control: 'boolean',\n      description: 'Whether the textarea is read-only'\n    },\n    required: {\n      control: 'boolean',\n      description: 'Whether the textarea is required'\n    },\n    name: {\n      control: 'text',\n      description: 'The name attribute for form submission'\n    },\n    id: {\n      control: 'text',\n      description: 'The unique identifier for the textarea'\n    }\n  }\n};\n\nconst Template = (args) => {\n  const element = document.createElement('ds-textarea');\n  \n  // Set attributes\n  if (args.value) {\n    element.setAttribute('value', args.value);\n  }\n  if (args.placeholder) {\n    element.setAttribute('placeholder', args.placeholder);\n  }\n  if (args.rows) {\n    element.setAttribute('rows', args.rows);\n  }\n  if (args.cols) {\n    element.setAttribute('cols', args.cols);\n  }\n  if (args.disabled) {\n    element.setAttribute('disabled', '');\n  }\n  if (args.readonly) {\n    element.setAttribute('readonly', '');\n  }\n  if (args.required) {\n    element.setAttribute('required', '');\n  }\n  if (args.name) {\n    element.setAttribute('name', args.name);\n  }\n  if (args.id) {\n    element.setAttribute('id', args.id);\n  }\n  \n  return element;\n};\n\nexport const Default = Template.bind({});\nDefault.args = {\n  placeholder: 'Enter your message here...',\n  rows: 4,\n  name: 'message'\n};\n\nexport const WithValue = Template.bind({});\nWithValue.args = {\n  value: 'This is a pre-filled textarea with some content that demonstrates how the component handles existing text.',\n  rows: 4,\n  name: 'message'\n};\n\nexport const Large = Template.bind({});\nLarge.args = {\n  placeholder: 'Enter a longer message...',\n  rows: 8,\n  cols: 50,\n  name: 'long-message'\n};\n\nexport const Small = Template.bind({});\nSmall.args = {\n  placeholder: 'Short message...',\n  rows: 2,\n  cols: 30,\n  name: 'short-message'\n};\n\nexport const Disabled = Template.bind({});\nDisabled.args = {\n  value: 'This textarea is disabled and cannot be edited.',\n  rows: 4,\n  disabled: true,\n  name: 'disabled-message'\n};\n\nexport const Readonly = Template.bind({});\nReadonly.args = {\n  value: 'This textarea is read-only and cannot be edited.',\n  rows: 4,\n  readonly: true,\n  name: 'readonly-message'\n};\n\nexport const Required = Template.bind({});\nRequired.args = {\n  placeholder: 'This field is required...',\n  rows: 4,\n  required: true,\n  name: 'required-message'\n}; ;export const __namedExportsOrder = [\"Default\",\"WithValue\",\"Large\",\"Small\",\"Disabled\",\"Readonly\",\"Required\"];"],"names":[],"sourceRoot":""}